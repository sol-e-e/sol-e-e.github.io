---
title: JavaScript - 프로토타입(Prototype)
date: '2022-09-02'
lastmod: '2025-08-22'
tags: ['JavaScript']
---

📝 자바스크립트의 강력하면서도 복잡한 기능인 프로토타입을 이해하기 위해 정리한 내용입니다.

## 프로토타입(Prototype)

자바스크립트는 **프로토타입 기반 언어**로 다른 객체지향 언어들이 클래스를 통한 상속을 사용하는 것과 달리, 자바스크립트는 프로토타입을 통해 객체 간 상속을 구현합니다. \
프로토타입 기반 상속이란 객체가 다른 객체로부터 속성과 메서드를 직접 상속받는 방식입니다. 자바스크립트에서는 객체를 생성하면, 해당 객체는 자신의 프로토타입 객체와 연결됩니다. 이 프로토타입 객체의 속성과 메서드를 마치 자신의 프로토타입 객체와 연결됩니다. \
프로토타입 시스템의 가장 큰 장점은 **메모리 효율성**입니다. 모든 인스턴스가 메서드를 각각 가지는 대신, 프로토타입에 한 번만 정의하여 모든 인스턴스가 공유할 수 있기 때문입니다. 수백 개의 객체가 있을 때, 각 객체마다 동일한 메서드를 복제하지 않고 프로토타입을 통해 공유함으로써 메모리를 크게 절약할 수 있습니다.

```javascript
// ❌ 비효율적인 방법
function Person(name) {
  this.name = name
  this.sayHello = function () {
    // 각 인스턴스마다 함수 복사
    console.log(`Hello, I'm ${this.name}`)
  }
}

const person1 = new Person('John')
const person2 = new Person('Chris')

console.log(person1.sayHello === person2.sayHello) // false (다른 함수)

// ✅ 효율적인 방법
function Person(name) {
  this.name = name
}

Person.prototype.sayHello = function () {
  // 프로토타입에 메서드 정의
  console.log(`Hello, I'm ${this.name}`)
}

const person1 = new Person('John')
const person2 = new Person('Chris')

console.log(person1.sayHello === person2.sayHello) // true (같은 함수)
```

## 프로토타입 용어 정리

### `prototype` 프로퍼티

`prototype` 프로퍼티는 **함수 객체만** 가지고 있는 특별한 프로퍼티입니다. 이 프로퍼티는 해당 함수가 생성자로 사용될 때, 생성되는 객체의 프로토타입이 될 객체를 가리킵니다.

```javascript
function Person(name) {
  this.name = name
}

Person.prototype.sayHello = function () {
  return `Hello, I'm ${this.name}`
}

// Person.prototype은 생성될 객체의 프로토타입이 됩니다.
```

### `constructor` 프로퍼티

모든 프로토타입 객체는 `constructor` 프로퍼티를 가지고 있으며, 이 프로퍼티는 해당 프로토타입 객체와 연결된 생성자 함수를 참조합니다. 이를 통해 객체가 어떤 생성자로부터 만들어졌는지 알 수 있습니다.

```javascript
const person = new Person('John')
console.log(Person.prototype.constructor === Person) // true
console.log(john.constructor === Person) // true
```

`john` 객체 자체는 `constructor` 프로퍼티를 가지고 있지 않지만, 프로토타입 체인을 통해 `Person.prototype`의 `constructor`에 접근할 수 있습니다.

### `[[Prototype]]` 내부 슬롯

모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 가지고 있습니다. 이는 내부 속성으로, 해당 객체의 프로토타입을 가리킵니다. 이 내부 슬롯은 직접 접근할 수 없으며, 대신 `Object.getPrototypeOf()` 메서드를 통해 접근할 수 있습니다.

```javascript
const proto = Object.getPrototypeOf(person) // person의 [[Prototype]]에 접근
console.log(proto === Person.prototype)
```

### `__proto__` 접근자

`__proto__`는 모든 객체가 가지고 있는 접근자 프로퍼티로, 해당 객체의 `[[Prototype]]` 내부 슬롯에 접근할 수 있게 해줍니다. 현재는 레거시 기능으로 간주되며, `Object.getPrototypeOf()`와 `Object.setPrototypeOf()`사숑이 권장됩니다.

```javascript
console.log(person.__proto__ === Person.prototype)
```

- 함수 객체는 `prototype` 프로퍼티를 가지며, 이는 생성자 함수로 만들어질 객체의 프로토타입을 가리킵니다.
- 모든 객체는 `[[Prototype]]` 내부 슬롯을 가지며, 이는 자신의 프로토타입 객체를 가리킵니다.
- `__proto__` 접근자 프로퍼티는 `[[Prototype]]` 내부 슬롯에 접근하기 위한 방법입니다.

## 프로토타입 체인

객체의 프로퍼티나 메서드에 접근할 때, 자바스크립트 엔진은 **프로토타입 체인**을 따라 탐색합니다.

### 객체 생성 시 프로토타입 연결 과정

```JavaScript
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  return `Hello, I'm ${this.name}`;
};

const john = new Person('John');
```

1. `new Person('John')`이 호출되면 새로운 빈 객체(`{}`)가 생성됩니다.
2. 이 객체의 `[[Prototype]]`은 `Person.prototype`으로 설정됩니다.
3. 생성자 함수 `Person`은 이 객체를 `this`로 하여 실행됩니다.
4. 함수 실행 결과로 만들어진 객체(`john`)가 반환됩니다.

### 프로퍼티 탐색 과정

```
객체 → 프로토타입 → 프로토타입의 프로토타입 → ... → null
```

```javascript
const grandfather = { lastName: 'Smith' }
const father = Object.create(grandfather)
father.firstName = 'John'
const son = Object.create(father)
son.name = 'Chris'

console.log(son.name) // 'Chris' - son 객체에서 찾음
console.log(son.firstName) // 'John' - father에서 찾음
console.log(son.lastName) // 'Smith' - grandfather에서 찾음
console.log(son.age) // undefined - 전체 체인에 없음
```

프로토타입 체인이 깊을수록 프로퍼티 검색에 더 많은 시간이 소요됩니다. 따라서 성능에 민감한 애플리케이션에서는 체인의 깊이를 최소화하고, 자주 접근하는 프로퍼티는 가능한 객체 자신에 정의하는 것이 좋습니다.

## 프로토타입 상속 구현 예제

### Object.create()

```javascript
function Animal(name) {
  this.name = name
}

Animal.prototype.speak = function () {
  return `${this.name} makes a noise.`
}

function Dog(name, breed) {
  Animal.call(this, name) // 부모 생성자 호출
  this.breed = breed
}

// Dog의 프로토타입을 Animal의 프로토타입을 상속받도록 설정
Dog.prototype = Object.create(Animal.prototype) // Dog.prototype을 새 객체로 덮어쓰면 constructor 연결이 끊김
Dog.prototype.constructor = Dog // constructor 복구

// Dog 프로토타입에 메서드 추가
Dog.prototype.speak = function () {
  return `${this.name} barks!`
}

const rex = new Dog('Rex', 'German Shepherd')
console.log(rex.speak()) // "Rex barks!"
```

### ES6의 클래스 문법

```javascript
class Animal {
  constructor(name) {
    this.name = name
  }

  speak() {
    return `${this.name} makes a noise.`
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name)
    this.breed = breed
  }

  speak() {
    return `${this.name} barks!`
  }
}

const rex = new Dog('Rex', 'German Shepherd')
console.log(rex.speak()) // "Rex barks!"
```

---

**참조**

[MDN - 객체 프로토타입](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes) \
[MDN - 상속과 프로토타입](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) \
[Prototype - 1. 프로토타입 객체](https://poiemaweb.com/js-prototype)
