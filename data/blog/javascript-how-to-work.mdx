---
title: JavaScript - 내부 동작(런타임, 콜 스택, 이벤트 루프)
date: '2022-09-07'
tags: ['JavaScript']
---

📝 자바스크립트의 내부 동작 메커니즘과 비동기 처리 방식을 정리한 내용입니다.

## 자바스크립트 실행 환경

### 싱글 스레드

자바스크립트는 본질적으로 싱글 스레드 기반입니다. 이는 한 번에 하나의 작업만 처리할 수 있습니다. 자바스크립트의 메인 스레드는 종종 "이벤트 루프"에서 태스크를 처리합니다.

싱글 스레드의 특성은 다음과 같은 의미를 갖습니다:

- **블로킹 연산의 위험**: 무거운 연산이 메인 스레드를 차단하면 전체 애플리케이션이 멈출 수 있습니다.
- **간단한 프로그래밍 모델**: 멀티스레드 환경에서 발생하는 복잡한 동기화 문제가 없습니다.
- **비동기 프로그래밍의 필요성**: 시간이 오래 걸리는 작업은 비동기적으로 처리해야 합니다.

이러한 싱글 스레드 제한을 극복하기 위해, 자바스크립트 런타임 환경(브라우저, Node.js)은 비동기 API와 이벤트 루프 매커니즘을 제공합니다.

## 자바스크립트 엔진

![Image](https://github.com/user-attachments/assets/5fb45483-c398-4f83-82ae-78a2b445b88c)

자바스크립트 엔진은 자바스크립트 코드를 실행하는 프로그램입니다. 가장 널리 알려진 자바스크립트 엔진은 Google의 V8(Chrome, Node.js), Mozilla의 SpiderMonkey(Firefox) 등이 있습니다.

### 메모리 힙(Memory Heap): 메모리 할당과 객체 저장

메모리 힙은 객체, 변수, 함수 등 프로그램에서 필요한 데이터가 저장되는 영역입니다.

주요 특성:

- **동적 메모리 할당**: 객체 생성 시 필요한 메모리를 동적으로 할당합니다.
- **가비지 컬렉션**: 더이상 참조되지 않는 객체를 자동으로 감지하고 메모리를 회수합니다.
- **메모리 누수 가능성**: 의도치 않게 객체에 대한 참조가 유지되면 메모리 누수가 발생할 수 있습니다.

### 콜 스택(Call Stack): 함수 실행 흐름과 호출 관리

콜 스택은 자바스크립트 프로그램의 실행 흐름을 추적하는 데이터 구조입니다. 함수가 호출될 때마다 해당 함수의 실행 컨텍스트가 스택의 맨 위에 추가(push)되고, 함수 실행이 완료되면 스택에서 제거(pop)됩니다.

주요 특성:

- **LIFO(Last In, First Out)**: 가장 나중에 들어온 함수가 가장 먼저 실행됩니다.
- **스택 오버플로우**: 콜 스택의 크기가 제한되어 있어, 재귀 호출이 너무 깊어지면 오버플로우가 발생할 수 있습니다.
- **동기적 실행**: 콜 스택의 작업은 항상 동기적으로 처리됩니다. 한 함수가 완료될 때까지 다른 작업은 기다립니다.

## 비동기 처리를 위한 런타임 구성 요소

자바스크립트는 싱글 스레드 언어이지만, 브라우저나, Node.js와 같은 런타임 환경에서는 비동기 처리를 할 수 있게 합니다.

![Image](https://github.com/user-attachments/assets/0a83c82b-b159-4326-bb04-4ce1f32aab6b)

### Web APIs (타이머, 네트워크 요청 등)

**브라우저 Web APIs**:

- 타이머: setTimeout(), setInterval()
- DOM API: 문서 조작 및 이벤트 처리
- Fetch API: 네트워크 요청
- Web Storage: localStorage, sessionStorage
- Geolocation, WebSockets, Web Workers 등

이러한 Web APIs는 자바스크립트 엔진에서 실행되지 않고, 브라우저에서 실행됩니다.

### 태스크 큐(Task Queue)와 마이크로태스크 큐(Microtask Queue)

#### 태스크 큐(Task Queue)

- `setTimeout`, `setInterval`, 사용자 이벤트 등의 콜백이 여기에 추가됩니다.
- 이벤트 루프는 한 번의 순회에서 태스크 큐에서 하나의 태스크만 처리합니다.

#### 마이크로태스크 큐(Microtask Queue)

- `Promise`, `MutationObserver` 등의 콜백이 여기에 추가됩니다.
- 이벤트 루프는 현재 실행 중인 태스크가 완료된 후, 다음 태스크를 처리하기 전에 마이크로태스크 큐의 모든 마이크로태스크를 처리합니다.
- 마이크로태스크는 새로운 마이크로태스크를 큐에 추가할 수 있으며, 이 경우 모든 마이크로태스크를 처리하고 나서 다음 태스크를 처리합니다.

```javascript
console.log('시작')

// 태스크 큐에 추가됨
setTimeout(() => {
  console.log('태스크 큐의 콜백')
}, 0)

// 마이크로태스크 큐에 추가됨
Promise.resolve()
  .then(() => {
    console.log('마이크로태스크 큐의 콜백 1')

    // 새로운 마이크로태스크 추가
    return Promise.resolve()
  })
  .then(() => {
    console.log('마이크로태스크 큐의 콜백 2')
  })

console.log('종료')

// 출력 순서: '시작', '종료', '마이크로태스크 큐의 콜백 1', '마이크로태스크 큐의 콜백 2', '태스크 큐의 콜백'
```

### 렌더링 큐(Animation Frames)

브라우저 환경에서는 화면 렌더링과 관련된 큐가 존재합니다.

- 애니메이션 프레임: `requestAnimationFrame()`을 통해 등록된 콜백이 저장됩니다.
- 브라우저는 일반적으로 60fps(frames per second)로 렌더링을 수행하며, 각 프레임마다 애니메이션 프레임 콜백을 실행합니다.
- 렌더링 큐는 태스크 큐와 마이크로태스크 큐 사이의 우선순위를 갖습니다.

### 이벤트 루프(Event Loop)

이벤트 루프는 태스크 큐, 마이크로태스크 큐, 렌더링 큐를 순회하며, 각 큐의 작업을 처리합니다.

**이벤트 루프 동작 순서**:

1. **콜 스택 확인**: 콜 스택이 비어 있는지 확인합니다.
2. **큐 순회**: 비어 있다면, 다음 우선순위에 따라 큐에서 작업을 가져와 실행합니다.
   2-1. **마이크로 태스크 실행**: 마이크로태스크 큐의 모든 작업을 실행합니다.
   2-2. **애니메이션 프레임 실행**: `requestAnimationFrame()`을 통해 등록된 콜백을 실행합니다.
   2-3. **태스크 큐 실행**: 태스크 큐에서 하나의 작업을 가져와 실행합니다.
3. **루프**: 이 과정을 지속적으로 반복합니다.

```javascript
console.log('스크립트 시작')

// 태스크 큐에 추가
setTimeout(() => {
  console.log('타이머 1')

  // 새로운 마이크로태스크 추가
  Promise.resolve().then(() => {
    console.log('타이머 1 내부의 프로미스')
  })
}, 0)

// 또 다른 태스크 큐에 추가
setTimeout(() => {
  console.log('타이머 2')
}, 0)

// 마이크로태스크 큐에 추가
Promise.resolve().then(() => {
  console.log('프로미스 1')

  // 새로운 마이크로태스크 추가
  queueMicrotask(() => {
    console.log('마이크로태스크')
  })
})

// 또 다른 마이크로태스크 큐에 추가
Promise.resolve().then(() => {
  console.log('프로미스 2')
})

console.log('스크립트 종료')

// 출력 순서:
// '스크립트 시작'
// '스크립트 종료'
// '프로미스 1'
// '마이크로태스크'
// '프로미스 2'
// '타이머 1'
// '타이머 1 내부의 프로미스'
// '타이머 2'
```

---

**참조**

[MDN - 이벤트루프](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Execution_model)
[JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue](https://www.lydiahallie.com/blog/event-loop)
